%% the-core.tex  
% цей розділ присвячений детальному огляду теорії, методів та алгоритмів


\chapter{Огляд процесу розробки конструкторської документації та порівняльний аналіз систем контролю версій}\label{ch:02}
В даному розділі ми розглядаємо процес розробки пакету конструкторської документації та проводимо огляд існуючих систем контрою версій.

\section{Аналіз існуючого методу розробки конструкторської документації} \label{ch:0201}

Процес розробки складається з сукупності послідовних стадій. В розробці конструкторської документації під стадією розуміється сукупність робіт, для яких укладається окремий план та кошторис і які направлені на досягнення певного кінцевого етапу, що піддається контролю та перевірці. В залежності від життєвого циклу виробу можна розділити процес розробки на такі узагальнені етапи як:

\begin{itemize}
  \item Дослідження
  \item Розробка
  \item Поставка продукції на виробництво та експлуатація
  \item Ремонт
  \item Зняття з виробництва
\end{itemize}

В свою чергу етап дослідження можна розділити на конкретніші задачі таким чином:
\begin{itemize}
  \item Проведення досліджень та розробка технічної пропозиції \footnote{Технічна пропозиція -- сукупність конструкторських документів, яке містить технічне та економічне обґрунтування доцільності розробки документації на виріб засновуючись на аналізі технічого завдання замовника, ймовірних варіантів конструкторських рішень та порівняння характеристик з існуючими аналогами (ГОСТ 2.103-68).}
  \item Розробка технічного завдання на дослідно-конструкторські та технологічні роботи.
\end{itemize}

Етап розробки можна підрозділити на такі конкретні операціні цикли:
\begin{itemize}
  \item Розробка езкізного проекту
  \item Розробка технічого проекту
  \item Розробка попередньої конструкторської документації на розробку дослідного взірця
  \item Виготовлення дослідного взірця
  \item Дослідження основних характеристик виробу на основі проведень випробувань з використанням дослідного взірця
  \item Доробка та коректування конструкторської документації на базі отриманих результатів випробувань
  \item Затвердження робочої версії конструкторської версії для організації промислового чи серійного виготовлення виробів
\end{itemize}

На етапі поставки продукції на виробництво та експлуатації проводяться такі дві основні операції:

\begin{itemize}	
  \item Виявлення недоліків та внесення коректив в констукторську документацію
  \item Розробка пакету експлуатаційної документації
\end{itemize}

Під етапом ремонту розуміється розробка робочої конструкторської документації для проведення ремонтних робіт.

Етап зняття виробництва передбачає розробку конструкторської документації на утилізацію.

В подальшому в даній роботі нами буде розглянуто етап розробки та способи оптимізації його підзадач.

\section{Спеціалізовані системи контролю версій} \label{ch:0202}

В цьому підрозділі ми розглянемо найпопулярніші системи контрою процесу розробки конструкторської документації та наведемо їх основні характеристики.

\subsection{ЛОЦМАН:PLM від компанії Аскон} 

ЛОЦМАН:PLM -- PDM продукт від компанії "<Аскон"> (www.ascon.ru) та надає такі базові функції:
\begin{itemize}
  \item Централізоване структуроване зберігання технічної документації на виріб
  \item Керування інформацією про сктруктуру, варіанти конфігурації виробів та входження компонентів в різні вироби
  \item Керування процесом розробки виробу та інгеграцію між собою компонентів САПР та технічних довідників та бібліотек компонентів  
\end{itemize}

На етапі підготовки виробництва система забезпечує централізований доступ та накопичення даних конструкторського проектування та комунікацію між різними інженерними службами підприємства. Затверджені дані та документація передаються у відповідні служби підприємства для матеріально-технічого забезпечення та налагодження випуску продукції.

Основним елементом зберігання ЛОЦМАН:PLM є склад виробу, що представляється у вигляді дерева побудови виробу. Вся конструкторська документація концентрується навколо складу виробу та вводиться в систему через клієнтську частину системи. Використовуючи прийняті стандарти система може працювати з КОМПАС-3D, SolidWorks, Autodesk Inventor, CATIA, Pro|ENGINEER Wildfire, Solid Edge, Unigraphics, AutoCAD, P-CAD, Microsoft Office. Інтеграція з САПР системами проходить на основі дерева виробу, по якому будується склад виробу та супровідну документацію.

Серед основних переваг ЛОЦМАН:PLM можна навести такі:
\begin{itemize}
  \item Наявність інтерфейсу доступу до системи з інших продуктів компанії "<Аскон">
  \item Облік конструкторської та розпорядницької документації в межах одного інтерфейсу
  \item Резервне копіювання та відновлення з ключових точок процесу розробки
  \item Моделювання користувацького інтерфейсу з можливістю підлаштовування під різні групи користувачів та типи документів без додаткового програмування
  \item Підключення до зовнішніх баз даних з можливістю імпорту інформації
  \item Опис бізнес-процесів підприємства з графічним представленням алгоритмів бізнес процесів
  \item Маршрутизація документів (WorkFlow), що включає в себе інтеграцію з системами електронної пошти
  \item Ведення процесу розробки згідно ГОСТу 2.503-90
  \item Електронний підпис документів з підтримкою криптографічних функцій ОС Windows
  \item Відкритий інтерфейс для підключення зовнішніх систем електронного підпису
  \item Використання корпоративних довідників при введені в базу даних про об’єкти виробництва
  \item Можливість зберігання документів в базі даних чи у файловій системі за вибором користувачів
  \item Інтеграція з довідковими базами даних та стандартними бібліотеками комплектації
  \item Можливість віддаленого доступу до баз даних через комп’ютерну мережу Internet через протокол TCP/IP при наявності VPN та можливість синхронізації двох та більше баз даних для територіально-відділених робочих областей
  \item Підтримка розробки спеціалізованих програмних рішень для різних областей виробництва та високий рівень масштабованості системи
  \item Широкі можливості створення додаткових модулів для розширення функціональності, використовуючи широкий набір API
  \item Можливість інтеграції з існуючими на ринку MRP/ERP-системами та зручний формат представлення даних
\end{itemize}

Сумарна вартість системи складає: 200 000 рос. рублів (6750 \$).

%Subsection для кожної з систем, також варто розглянути спеціалізовані системи для конкретних САПР
% \subsection{Спеціалізовані системи контролю версій}

\subsection{PDM система від компанії SolidWorks}

% SolidWorks product data management (PDM) solutions help you get your design data under control. You can securely store and index your design data for fast retrieval, eliminate concerns about version control and data loss, and even share and collaborate on designs online with people outside your organization. With SolidWorks PDM solutions, you can substantially improve the way your teams manage and collaborate on design.
% 
% SolidWorks PDM software is easy to implement, requiring little IT support, and can be customized to your project workflow. With tight integration to SolidWorks design software, your team can focus on product development and innovation. You improve the productivity of your product development process, no matter the size and distribution of your organization.

PDM система від компанії SolidWorks забезпечує контроль за даними та процесом розробки, вона забезпечує безпеку та зручні інструменти для управління супровідними процесами та виготовленням виробів. Ця пропозиція забезпечує безпечний доступ для віддалених працівників та зручну інтеграцію CAD продуктів компанії SolidWorks. Також важливою перевагою є те, що дана система не вимагає значного штату IT відділу для підтримки та управління.


\section{Універсальні системи контролю версій}

\subsection{Git}

\subsection{Mercurial}
Mercurial - це кросплатформенна, розподілена система контролю версій. Підтримує такі системи, як Windows та UNIX-подібні, такі як FreeBSD, MacOS і Linux. 
Весь Mercurial представляє собою одну програму hg яка виконує усі необхідні дії, вказівки програмі передаються через параметри командної стрічки.
\subsubsection{Технічна інформація}
Mercurial використовує SHA-1 хеш для визначення змін. Для доступу до сховища по мережі, Mercurial використовує HTTP-протокол, який спрямований на скорочення часу прийому запитів, нових зв'язків і передачі даних. Mercurial також може працювати через SSH протокол, де дуже схожий на HTTP-протокол. За замовчуванням використовується 3-шляхове злиття до виклику зовнішніх інструментів злиття.
\subsection{Порівняння Git та Mercurial}
 В цих систем є багато спільного. Тут розглянемо відмінні риси кожної з них
\subsubsection{Переваги Git}
\begin{itemize}
 \item \textbf{Клієнтське управління зберіганням}. Обидва Mercurial і Git дозволяють користувачам вибірково витягувати гілки з інших сховищ. Це дає авансом механізм для скорочення локальної історії. Крім того, Git дозволяє скасовувати попередньо витягнуті гілки. Git також дозволяє старі дані перегляд бути скорочені з локального репозиторія (зберігаючи останні дані ревізії на тих галузях). В Mercurial, якщо гілка знаходиться в локальному сховищі, то всі її зміни (до самої початкової фіксації) повинні бути присутніми, і немає ніякого способу, щоб обрізати гілки, крім створення нового сховища і вибіркового переміщення гілок в нього. Були деякі роботи у вирішенні цієї проблеми в Mercurial, але нічого офіційного поки немає.
\item \textbf{Кількість предків}. Git підтримує необмежену кількість предків під час злиття. Mercurial допускає тільки двох предків. Для того щоб досягти багатошляхового злиття в Mercurial, користувачеві доведеться виконати N-1 двосторонніх злиттів. Хоча в багатьох випадках це також хороший спосіб об'єднати N предків, незалежно від DVCS з Git, користувач може виконувати N-шляхове злиття в один крок, якщо він цього забажає.
\item \textbf{Перебазування}. Git має команду перебазування, яка дозволяє змінити точку розгалуження локальної гілки на більш свіжу версію. Наприклад, якщо він працює над новою функцією для продукту, локальна гілка може бути запущена з версії 1.0. Якщо коли я все ще працюю над функцією, основна лінія продукту була оновлена до 1.1, можна перенести гілку, і вважати що вона починається з 1,1 замість 1,0. У більшості інших систем, це буде зроблено шляхом злиття 1,1 і локальної гілки. Злиття це правильно з точки зору SCM, де акцент робиться на відтворюваність минулих станів. Однак, коли в центрі уваги "авторська чистота історії змін ', перебазування іноді є кращим способом. Git-перебазування дозволяє зробити раніше нелінійну історію лінійною, ведення історії чистішим.
\end{itemize}
\subsubsection{Переваги Mercurial}
\begin{itemize}
 \item Крива вивчення. Git має крутішу криву вивчення ніж Mercurial через низку факторів.Git має багато команд, об’єм яких може злякати користувачів початківців. Документація Mercurial прагне бути більш повноюі простішою для новачків. Термінологія та команди Mercurial є ближчою до Subversion та  CVS завдяки чому є простішою для освоєння мігрантами з цих систем.
\item Підтримка Windows. Git сильно прив’язаний до Linux, офіційним шлях для запуску його під Windows є cygwin. Порт, який базується на MinGW є повністю функціональним, але Windows все ще є системою ``другого класу'' для Git.   
\item Обслуговування. Git вимагає періодичного обслуговування репозиторіїв. Mercurial не потребує такого обслуговування.
\item Незмінна історія. Git може виконувати майже все, що вкаже користувач. Нажаль іноді це може бути небезпечним, наприклад він може пошкодити історію. Натомість репозиторій Mercurial створений як сутність що завжди росте і складається з незмінних об’єктів.
\end{itemize}

\section{Порівняльний аналіз розглянутих систем контролю версій} \label{ch:0203}

% Можна створити якісь таблиці для порівняння та наглядності, треба киоритстати tikZ

% % Одні з перших засадничих робіт, присвячених процесам самоорганізації, належать Розенблату~\cite{Ros1963}, у яких висвітлено головні ідеї, сформульовані для математичних моделей штучних нейронних мереж. Запропоновані підходи не дали практичного результату, але заклали підґрунтя для  подальших досліджень~\cite{ShlHlav2004}. В Україні дослідження моделювання систем на основі процесів самоорганізації представлене науковою школою О.Г. Івахненка, яким було суттєво розвинене вчення про індуктивне моделювання~\cite{Iva1982}. Напрацювання школи Івахненка набули міжнародного визнання~\cite{MaIv1994}.
% 
% \section{Перший підрозділ}\label{ch:0201}
% 
% % Із досліджень у нейробіології відомо, що різні частини кори головного мозку організовані у відповідності до різних видів чуття~\cite{Koh2001}. Деякі новітні дослідження людського мозку вказують на те, що сигнали-реакції формуються на корі головного мозку в тому самому топологічному порядку, в якому вони були отримані органами чуття (наприклад, очима). Карти Кохонена слідують тому самому принципу, будуючи відображення вхідного простору на ґратку своїх елементів у топологічно впорядкований спосіб. Такий зв'язок із способом функціонування головного мозку зумовив класифікацію карт Кохонена як окремої архітектури штучних нейронних мереж~\cite{RMS1992}. Тому карту Кохонена також називають \emph{нейромережею Кохонена}, а її елементи -- \emph{нейронами}.
% 
% \subsection{Перший підрозділ першого підрозділу}
% 
% \begin{table}
%    \centering
%    \caption{Приклад балиці}
%    \label{tbl:medical-data-fragment}
%    \def~{\phantom{0}}
%    \def\ExSp#1{\noalign{\vskip #1}}
%    \def\Hline{\noalign{\hrule height 2\arrayrulewidth}}
%    \begin{tabular}{cccccccccccccccc}
%      \ExSp{0.2ex} \Hline \ExSp{1ex}
%      \rotatebox{45}{\tiny AGE} & \rotatebox{45}{\tiny G} & \rotatebox{45}{\tiny PIK} & \rotatebox{45}{\tiny KHK\_AKMK} & \rotatebox{45}{\tiny KV} & \rotatebox{45}{\tiny SK} & \rotatebox{45}{\tiny UA} & \rotatebox{45}{\tiny AA} & \rotatebox{45}{\tiny BE} & \rotatebox{45}{\tiny OH} & \rotatebox{45}{\tiny REW} & \rotatebox{45}{\tiny R\_AK} & \rotatebox{45}{\tiny R\_MK} & \rotatebox{45}{\tiny R\_AKMK} & \rotatebox{45}{\tiny GH} & \rotatebox{45}{\tiny KHKS}\\
%      \ExSp{0.2ex} \hline\ExSp{1ex}
%      0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \cellcolor[gray]{0.9}1\\
%      1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & \cellcolor[gray]{0.9}0\\
%      1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \cellcolor[gray]{0.9}1\\
%      1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \cellcolor[gray]{0.9}1\\
%      \ExSp{1ex} \hline
%    \end{tabular}
% \end{table}
% 
% \begin{table}
%   \centering
%   \caption{Приклад ще однієї таблиці}
%   \label{tbl:medical-data-stats}        
%   \def~{\phantom{0}}
%   \def\exsp#1{\noalign{\vskip #1}}
%   \def\hline{\noalign{\hrule height 2\arrayrulewidth}}
%   \begin{tabular}{ccccc}
%   \exsp{0.2ex} \hline \exsp{1ex}
%   \rotatebox{45}{\smallК-сть хворих} & \rotatebox{45}{\smallВідсоток хворих} & \rotatebox{45}{\smallК-сть здорових} & \rotatebox{45}{\smallВідсоток здорових} & \rotatebox{45}{\smallЗагальна к-сть}\\
%   \exsp{0.2ex} \hline\exsp{1ex}
%   756 & 21.6\% & 2744 & 78.4\% & 3500\\
%   \exsp{1ex} \hline
%   \end{tabular}
% \end{table}

\subsection{Другий підрозділ першого підрозділу}

% \begin{algorithm}[!htb]
% \caption{Приклад вербальної форми опису алгоритму.}\label{alg:classifier}
% \begin{enumerate}
% \item[ ]\emph{Ініціалізація.} Запровадимо пару змінних $(a_i,b_i)$ для кожного елемента $m_i\in M$, які міститимуть кількість реагувань елемента на хворих та здорових пацієнтів. Присвоюємо $a_i\leftarrow 0$, $b_i\leftarrow 0$, $i=\overline{1,|M|}$. Вибираємо множину вхідних даних, для якої обчислюватиметься успішність класифікації, яку позначимо $T$. Уводимо множину елементів-переможців $K\leftarrow\varnothing$.
% \item[1.] Вибираємо вхідний вектор $x\in T$ і вилучаємо його, покладаючи $T\leftarrow T\setminus\{x\}$.
% \item[2.] Для вектора $x$ визначаємо переможця $m(x)$ відповідно до співвідношення~(\ref{eq:winner}); покладаємо $K\leftarrow K\cup\{m(x)\}$.
% \item[3.] Якщо вектору $x$ відповідає ознака прийняття рішень зі значення 1 (хворі пацієнти), то покладаємо $a_{m(x)}\leftarrow a_{m(x)} + 1$, інакше -- $b_{m(x)}\leftarrow b_{m(x)} + 1$.
% \item[4.] Якщо $T\neq \varnothing$, то повертаємось на крок 1.
% \item[5.] Обчислимо успішність кожного елемента $m\in K$:\\$s_k=\dfrac{\xi_k}{a_k + b_k}*100$, $k\in I(K)$, де $I(K)$ -- множина індексів елементів-переможців, $\xi_k=\left\{\begin{array}{r@{,\quad}l}a_k & a_k\geq b_k \\ b_k & a_k < b_k\end{array}\right.$
% \item[6.] Обчислюємо загальну успішність класифікації: \begin{eqnarray*}S=\dfrac{1}{|K|}\sum_{k=I(K)}s_k,\end{eqnarray*} де $|K|$ -- кількість елементів-переможців для векторів множини $T$.
% \end{enumerate}
% \end{algorithm}

\section{Висновки до розділу~\ref{ch:02}}
У цьому розділі наведено результати дослідження\ldots